일시: 2025.11.16
작성자: 박신형

스터디 중 나왔던 질문들을 정리한 내용입니다.... 
작성 과정에서 LLM을 사용해 보완했기 때문에 실제 발언과 일부 차이가 있을 수 있으나, 누락된 부분은 최대한 정확하게 재구성하여 기록했습니다..!

1. RAG와 VectorStoreMemory의 차이 논의

스터디에서는 먼저 RAG(Retrieval-Augmented Generation)와 VectorStoreMemory가 동일하게 벡터 기반 기술을 사용하는데, 이 둘의 경계가 모호하다는 문제 제기에서 논의가 시작되었다. 이에 대해 RAG는 벡터를 “저장하는 기술”이라기보다는 외부 지식을 효율적으로 검색·매칭하기 위한 알고리즘적 구조라는 설명이 있었다. 반면 VectorStoreMemory는 사용자의 대화 히스토리를 벡터로 저장하고 이후 유사한 맥락을 검색하는 메모리 시스템에 가깝다는 의견이 제시되었다.
결론적으로, 두 기술은 모두 벡터를 사용하나 목적이 다르며, RAG는 외부 지식 검색을 위주로 하고, VectorStoreMemory는 개인 대화 맥락을 기억하는 데 집중하는 기술이라는 점이 정리되었다.

2. SummaryMemory의 토큰 증가 여부

SummaryMemory가 대화를 지속적으로 요약하는 방식이므로 토큰이 계속 늘어나는 것 아니냐는 질문이 제기되었다. 이에 대해 SummaryMemory는 대화 전체를 압축한 하나의 요약만 유지하기 때문에, 대화량이 증가해도 토큰이 누적되지 않는 구조라는 설명이 있었다.
따라서 SummaryMemory는 토큰 증가 문제 없이 비교적 안정적으로 장기 기억을 유지하는 방식으로 이해되었다.

3. TokenBufferMemory의 동작 방식

TokenBufferMemory에서 토큰 제한을 설정했을 때 초과되는 부분을 어떻게 처리하는지에 대한 질문이 이어졌다. 이에 대해 TokenBufferMemory는 **오래된 메시지를 순차적으로 삭제(FIFO)**하는 방식으로 동작하며, 요약 기능을 사용하지 않는다는 점이 명확히 확인되었다. 즉, TokenBufferMemory는 최신 대화를 최대한 유지하고 오래된 대화부터 제거하는 단순한 구조로 작동한다는 결론이 도출되었다.

4. ConversationBufferWindowMemory의 프롬프트 길이 제한 여부

마지막으로, ConversationBufferWindowMemory가 최근 k개의 상호작용만을 기억하도록 설정한 경우, 프롬프트 전체 길이에 대한 별도의 제한이 있는지에 대한 논의가 있었다. 이에 대해 이 방식은 토큰이 아니라 메시지 개수 기반으로 관리되기 때문에 프롬프트가 지나치게 길어질 가능성이 크지 않으며, 실전에서도 큰 문제가 되지 않을 것이라는 의견이 제시되었다.
다만 이론적으로는 프롬프트에 포함되기 때문에 제한이 존재할 수 있으나, k를 작게 유지하는 만큼 실제 영향은 미미한 것으로 결론 지어졌다.
